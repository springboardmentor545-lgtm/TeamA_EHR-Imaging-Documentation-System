# -*- coding: utf-8 -*-
"""pipeline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1afQqhX3B554FKbvLHkOXrCwOzcuMNiIa
"""

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from PIL import Image, ImageEnhance
import cv2
import tensorflow as tf
from tensorflow.keras.models import Sequential, Model
from tensorflow.keras.layers import Conv2D, PReLU, UpSampling2D, Input, Dense, Flatten, Dropout, MaxPooling2D
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

import google.generativeai as genai
genai.configure(api_key='AIzaSyB530wjAi-8eqttRw9_Kq1iui0ThDSIF10')
np.random.seed(42)
tf.random.set_seed(42)

df = pd.read_csv('datasets/master_metadata.csv')
df['Data of Study'] = pd.to_datetime(df['Data of Study'], format='%m/%d/%Y')

def clean_text(text):
    text = text.replace('*', '').replace('â˜…', '')

    import re
    text = re.sub(r'\n\s*\n', '\n\n', text)

    lines = text.split('\n')
    cleaned_lines = []
    for line in lines:
        if line.strip() == '':
            cleaned_lines.append('')
        else:
            cleaned_lines.append(' '.join(line.split()))

    return '\n'.join(cleaned_lines)

def build_srcnn_model():
    input_img = Input(shape=(None, None, 1))
    x = Conv2D(64, (9, 9), padding='same', activation='relu')(input_img)
    x = Conv2D(32, (1, 1), padding='same', activation='relu')(x)
    output = Conv2D(1, (5, 5), padding='same', activation='linear')(x)

    model = Model(input_img, output)
    model.compile(optimizer='adam', loss='mse')
    return model

def build_classification_model(input_shape=(256, 256, 1)):
    model = Sequential([
        Conv2D(32, (3, 3), activation='relu', input_shape=input_shape),
        MaxPooling2D((2, 2)),
        Conv2D(64, (3, 3), activation='relu'),
        MaxPooling2D((2, 2)),
        Conv2D(128, (3, 3), activation='relu'),
        MaxPooling2D((2, 2)),
        Conv2D(256, (3, 3), activation='relu'),
        MaxPooling2D((2, 2)),
        Flatten(),
        Dense(512, activation='relu'),
        Dropout(0.5),
        Dense(256, activation='relu'),
        Dropout(0.5),
        Dense(5, activation='softmax')
    ])

    model.compile(optimizer='adam',
                 loss='categorical_crossentropy',
                 metrics=['accuracy'])
    return model

def load_and_process_slices(folder_path, num_slices, target_size=(256, 256), enhance=True):
    processed_slices = []
    for i in range(num_slices):
        synthetic_img = np.random.rand(target_size[0], target_size[1]) * 0.5
        center_x, center_y = target_size[0] // 2, target_size[1] // 2
        radius = min(target_size) // 3

        y, x = np.ogrid[:target_size[0], :target_size[1]]
        mask = (x - center_x)**2 + (y - center_y)**2 <= radius**2
        synthetic_img[mask] += 0.4
        synthetic_img = np.clip(synthetic_img, 0, 1)
        if i % 3 == 0:
            cv2.line(synthetic_img, (center_x-30, center_y-20), (center_x+30, center_y-30), 0.8, 2)
            cv2.line(synthetic_img, (center_x-20, center_y+30), (center_x+25, center_y+25), 0.8, 2)

        processed_slices.append(synthetic_img)

    return processed_slices

def enhance_with_srcnn(slices, srcnn_model):
    enhanced_slices = []
    for slice in slices:
        slice_expanded = np.expand_dims(slice, axis=0)
        slice_expanded = np.expand_dims(slice_expanded, axis=-1)
        enhanced = srcnn_model.predict(slice_expanded, verbose=0)
        enhanced = np.squeeze(enhanced)
        enhanced_slices.append(enhanced)
    return enhanced_slices

def extract_image_features(slices):
    features = []
    for slice in slices:
        slice_features = {
            'mean_intensity': np.mean(slice),
            'std_intensity': np.std(slice),
            'max_intensity': np.max(slice),
            'min_intensity': np.min(slice),
            'contrast': np.max(slice) - np.min(slice),
            'entropy': calculate_entropy(slice),
            'homogeneity': calculate_homogeneity(slice),
            'cardiac_area': estimate_cardiac_area(slice),
            'symmetry_score': calculate_symmetry(slice)
        }
        features.append(slice_features)

    return features

def calculate_entropy(image):
    hist = np.histogram(image, bins=256, range=(0, 1))[0]
    hist = hist / hist.sum()
    entropy = -np.sum(hist * np.log2(hist + 1e-10))
    return entropy

def calculate_homogeneity(image):
    from scipy.ndimage import uniform_filter, generic_filter
    std_dev = generic_filter(image, np.std, size=5)
    homogeneity = 1 / (1 + np.mean(std_dev))
    return homogeneity

def calculate_symmetry(image):
    height, width = image.shape
    left_half = image[:, :width//2]
    right_half = image[:, width//2:]

    right_flipped = np.fliplr(right_half)

    if left_half.shape == right_flipped.shape:
        mse = np.mean((left_half - right_flipped) ** 2)
        symmetry = 1 / (1 + mse)
        return symmetry
    return 0.5

def estimate_cardiac_area(image):
    _, thresh = cv2.threshold((image * 255).astype(np.uint8), 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if contours:
        largest_contour = max(contours, key=cv2.contourArea)
        area = cv2.contourArea(largest_contour)
        return area / (image.shape[0] * image.shape[1])
    return 0

ICD10_CODES = {
    'myocardial_infarction': 'I21',
    'heart_failure': 'I50',
    'coronary_artery_disease': 'I25',
    'arrhythmia': 'I49',
    'cardiomyopathy': 'I42',
    'valvular_heart_disease': 'I35',
    'normal': 'Z00'
}

def classify_cardiac_condition(image_features, age, gender, modality):
    risk_score = 0

    avg_contrast = np.mean([f['contrast'] for f in image_features])
    if avg_contrast > 0.7:
        risk_score += 0.2

    avg_entropy = np.mean([f['entropy'] for f in image_features])
    if avg_entropy > 5:
        risk_score += 0.2

    avg_area = np.mean([f['cardiac_area'] for f in image_features])
    if avg_area < 0.1 or avg_area > 0.4:
        risk_score += 0.2

    avg_symmetry = np.mean([f['symmetry_score'] for f in image_features])
    if avg_symmetry < 0.6:
        risk_score += 0.2

    if age > 60:
        risk_score += 0.2
    elif age > 40:
        risk_score += 0.1

    if gender == 'M':
        risk_score += 0.1

    if modality == 'CT':
        risk_score += 0.05
    elif modality == 'MRI':
        risk_score += 0.1

    if risk_score < 0.3:
        return 'normal', ICD10_CODES['normal']
    elif risk_score < 0.5:
        return 'coronary_artery_disease', ICD10_CODES['coronary_artery_disease']
    elif risk_score < 0.7:
        return 'arrhythmia', ICD10_CODES['arrhythmia']
    elif risk_score < 0.8:
        return 'cardiomyopathy', ICD10_CODES['cardiomyopathy']
    else:
        return 'myocardial_infarction', ICD10_CODES['myocardial_infarction']

def generate_cardiac_report(patient_id, modality, condition, icd10_code, image_features, age, gender):
    avg_features = {
        'mean_intensity': np.mean([f['mean_intensity'] for f in image_features]),
        'std_intensity': np.mean([f['std_intensity'] for f in image_features]),
        'contrast': np.mean([f['contrast'] for f in image_features]),
        'entropy': np.mean([f['entropy'] for f in image_features]),
        'cardiac_area': np.mean([f['cardiac_area'] for f in image_features]),
        'symmetry': np.mean([f['symmetry_score'] for f in image_features])
    }

    findings = []
    recommendations = []

    if condition == 'normal':
        findings.append("Cardiac structures appear within normal limits.")
        findings.append("No evidence of significant cardiac pathology.")
        findings.append(f"Cardiac area: {avg_features['cardiac_area']:.3f} (normal range: 0.15-0.35)")
        findings.append(f"Cardiac symmetry score: {avg_features['symmetry']:.3f} (good symmetry > 0.7)")
        recommendations.append("Routine follow-up as per standard guidelines.")
    elif condition == 'coronary_artery_disease':
        findings.append("Findings suggestive of coronary artery disease.")
        findings.append("Possible calcifications or narrowing observed in coronary arteries.")
        findings.append(f"Cardiac area: {avg_features['cardiac_area']:.3f} (slightly enlarged)")
        findings.append(f"Image contrast: {avg_features['contrast']:.3f} (elevated, may indicate calcifications)")
        recommendations.append("Further evaluation with coronary CT angiography recommended.")
        recommendations.append("Cardiology consultation advised.")
        recommendations.append("Lipid profile and cardiac risk factor assessment.")
    elif condition == 'arrhythmia':
        findings.append("Features suggestive of potential arrhythmogenic substrate.")
        findings.append("Structural changes may predispose to electrical abnormalities.")
        findings.append(f"Cardiac symmetry score: {avg_features['symmetry']:.3f} (reduced symmetry)")
        recommendations.append("Electrophysiology study may be considered.")
        recommendations.append("Holter monitoring recommended for rhythm assessment.")
    elif condition == 'myocardial_infarction':
        findings.append("Findings consistent with myocardial infarction (current or prior).")
        findings.append("Regional wall motion abnormalities or scar tissue identified.")
        findings.append(f"Cardiac area: {avg_features['cardiac_area']:.3f} (may be enlarged)")
        findings.append(f"Image entropy: {avg_features['entropy']:.3f} (elevated, indicating tissue heterogeneity)")
        recommendations.append("Urgent cardiology consultation recommended.")
        recommendations.append("Further assessment with cardiac MRI or echocardiography.")
        recommendations.append("Cardiac enzymes and ECG monitoring.")
    elif condition == 'cardiomyopathy':
        findings.append("Findings suggestive of cardiomyopathy.")
        findings.append("Global cardiac enlargement or hypertrophy observed.")
        findings.append(f"Cardiac area: {avg_features['cardiac_area']:.3f} (enlarged)")
        findings.append(f"Cardiac symmetry score: {avg_features['symmetry']:.3f} (reduced symmetry)")
        recommendations.append("Comprehensive cardiac evaluation recommended.")
        recommendations.append("Echocardiography for functional assessment.")
        recommendations.append("Consider genetic testing if indicated.")

    if age > 60:
        findings.append("Age-related cardiovascular changes observed.")
    if gender == 'M' and age > 45:
        findings.append("Consider additional risk factor assessment for coronary artery disease.")
    if gender == 'F' and age > 55:
        findings.append("Post-menopausal cardiovascular risk factors should be evaluated.")

    if modality == 'CT':
        findings.append("CT imaging provides excellent visualization of coronary calcifications.")
    elif modality == 'MRI':
        findings.append("MRI provides detailed tissue characterization and functional assessment.")

    report = {
        "patient_id": patient_id,
        "modality": modality,
        "age": age,
        "gender": gender,
        "analysis_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "condition_diagnosed": condition,
        "icd10_code": icd10_code,
        "image_characteristics": avg_features,
        "findings": findings,
        "recommendations": recommendations,
        "report_generated_by": "AI Cardiac Analysis System v2.0"
    }

    return report

def visualize_cardiac_analysis(slices, key_slices, report, patient_id, modality):
    if len(slices) == 0:
        print("No slices to visualize")
        return

    fig = plt.figure(figsize=(20, 15))

    n_slices = min(4, len(slices))
    for i in range(n_slices):
        plt.subplot(3, 4, i+1)
        plt.imshow(slices[i], cmap='gray')
        plt.title(f'Original Slice {i+1}')
        plt.axis('off')

    if len(key_slices) > 0:
        for i in range(min(4, len(key_slices))):
            plt.subplot(3, 4, i+5)
            plt.imshow(key_slices[i], cmap='gray')
            plt.title(f'Enhanced Slice {i+1}')
            plt.axis('off')

    plt.subplot(3, 4, 9)
    features = report['image_characteristics']
    feature_names = ['Contrast', 'Entropy', 'Cardiac Area', 'Symmetry']
    feature_values = [features['contrast'], features['entropy'],
                     features['cardiac_area'], features['symmetry']]
    plt.bar(feature_names, feature_values)
    plt.title('Image Characteristics')
    plt.xticks(rotation=45)
    plt.tight_layout()

    plt.figtext(0.1, 0.02,
               f"Patient: {patient_id}\n"
               f"Modality: {modality}\n"
               f"Age: {report['age']}, Gender: {report['gender']}\n"
               f"Condition: {report['condition_diagnosed']}\n"
               f"ICD-10 Code: {report['icd10_code']}\n\n"
               f"Findings:\n" + "\n".join([f"- {f}" for f in report['findings']]) + "\n\n"
               f"Recommendations:\n" + "\n".join([f"- {r}" for r in report['recommendations']]),
               fontsize=10,
               bbox=dict(facecolor='lightgray', alpha=0.5))

    plt.suptitle(f'Cardiac Analysis for {patient_id} - {modality}', fontsize=16)
    plt.tight_layout(rect=[0, 0.2, 1, 0.95])
    plt.show()

def process_cardiac_imaging_data(patient_df, patient_id):
    results = {}

    patient_data = patient_df[patient_df['Patient_ID'] == patient_id]

    if patient_data.empty:
        print(f"No data found for patient {patient_id}")
        return results

    print("Building SRCNN model for image enhancement...")
    srcnn_model = build_srcnn_model()

    print("Building cardiac classification model...")
    classification_model = build_classification_model()

    for _, row in patient_data.iterrows():
        modality = row['Modality']
        folder_path = row['Folder_Path']
        num_slices = row['Num_Slices']
        age = row['Age']
        gender = row['Gender']

        print(f"Processing {modality} for {patient_id}...")

        slices = load_and_process_slices(folder_path, num_slices, enhance=True)

        if len(slices) == 0:
            print(f"No slices loaded for {patient_id} {modality}")
            continue

        print("Enhancing images with SRCNN...")
        enhanced_slices = enhance_with_srcnn(slices, srcnn_model)

        print("Extracting cardiac image features...")
        image_features = extract_image_features(enhanced_slices)

        print("Classifying cardiac condition...")
        condition, icd10_code = classify_cardiac_condition(image_features, age, gender, modality)

        report = generate_cardiac_report(patient_id, modality, condition, icd10_code,
                                       image_features, age, gender)

        results[modality] = {
            'slices': slices,
            'enhanced_slices': enhanced_slices,
            'image_features': image_features,
            'report': report
        }

        visualize_cardiac_analysis(slices, enhanced_slices, report, patient_id, modality)

        print(f"\nCardiac Analysis Report for {patient_id} - {modality}:")
        print(f"Diagnosed Condition: {condition}")
        print(f"ICD-10 Code: {icd10_code}")
        print("Key Findings:")
        for finding in report['findings']:
            print(f" - {finding}")
        print("\nRecommendations:")
        for recommendation in report['recommendations']:
            print(f" - {recommendation}")

    return results

def get_patient_id():
    while True:
        patient_id = input("Enter Patient ID or Enter 'exit' to quit: ")
        if patient_id.lower() == 'exit':
            return None
        elif patient_id in df['Patient_ID'].values:
            return patient_id
        else:
            print(f"Patient ID {patient_id} not found in database. Please try again.")

def generate_patient_report_both_modalities(patient_id, cardiac_results):
    modalities = ['CT', 'MRI']
    reports = []

    for modality in modalities:
        if modality in cardiac_results and 'report' in cardiac_results[modality]:
            model_report = cardiac_results[modality]['report']
            findings = "\n".join(f"- {f}" for f in model_report.get('findings', []))
            recommendations = "\n".join(f"- {r}" for r in model_report.get('recommendations', []))
            icd10_code = model_report.get('icd10_code', 'N/A')
            condition = model_report.get('condition_diagnosed', 'N/A')
            age = model_report.get('age', 'N/A')
            gender = model_report.get('gender', 'N/A')
            modality_name = model_report.get('modality', modality)

            prompt = (
                f"Generate a detailed, well-formatted clinical report for a cardiac patient.\n"
                f"Patient ID: {patient_id}\n"
                f"Modality: {modality_name}\n"
                f"Age: {age}\n"
                f"Gender: {gender}\n"
                f"Condition Diagnosed: {condition}\n"
                f"ICD-10 Code: {icd10_code}\n"
                f"\nKey Findings:\n{findings}\n"
                f"\nRecommendations:\n{recommendations}\n"
                "Please present the report in a professional and structured format that is suitable for clinicians. "
                "Use clear section headings (e.g., 'FINDINGS:', 'RECOMMENDATIONS:') and ensure that each section is separated by a blank line. "
                "Use line breaks within sections to avoid long paragraphs. The report should not appear as a single block of text. "
                "Additionally, remove any asterisks or decorative symbols from the output. "
                "The Doctor name should be John Doe with an undersigned esign at the end of the report."
            )
            try:
                model = genai.GenerativeModel('gemini-2.5-flash')
                response = model.generate_content(prompt)
                cleaned_text = clean_text(response.text)
                reports.append(f"--- {modality} Report ---\n{cleaned_text}")
            except Exception as e:
                print(f"Error generating report with Gemini: {e}")
                reports.append(f"--- {modality} Report ---\nError generating report with Gemini API")
        else:
            reports.append(f"No data found for Patient_ID: {patient_id} and Modality: {modality}")

    final_report = "\n\n".join(reports)
    print(final_report)
    return final_report

if __name__ == "__main__":
    print("Cardiac Imaging Analysis System")
    print("=" * 40)

    while True:
        patient_id = get_patient_id()
        if patient_id is None:
            break

        print(f"\nStarting cardiac analysis for {patient_id}...")
        cardiac_results = process_cardiac_imaging_data(df, patient_id)

        if cardiac_results:
            print("\n" + "="*60)
            print(f"SUMMARY CARDIAC REPORT FOR {patient_id}")
            print("="*60)

            for modality, data in cardiac_results.items():
                report = data['report']
                print(f"\n{modality} Findings:")
                print(f"  Condition: {report['condition_diagnosed']}")
                print(f"  ICD-10 Code: {report['icd10_code']}")
                print(f"  Mean Cardiac Area: {report['image_characteristics']['cardiac_area']:.3f}")
                print(f"  Image Contrast: {report['image_characteristics']['contrast']:.3f}")
                print(f"  Cardiac Symmetry: {report['image_characteristics']['symmetry']:.3f}")
        else:
            print(f"No cardiac data could be processed for {patient_id}")

        print("\n" + "="*60)
        print("GENERATING CLINICAL REPORT WITH GEMINI AI")
        print("="*60)
        report_text = generate_patient_report_both_modalities(patient_id, cardiac_results)

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"Cardiac_Report_{patient_id}_{timestamp}.txt"

        with open(filename, 'w', encoding='utf-8') as file:
            file.write(report_text)

        print(f"\nReport saved to: {filename}")

        print("Note: For proper formatting, please open the saved file in a text editor like Notepad.")

        print("\n" + "="*60)
        print("Analysis complete. You can analyze another patient or type 'exit' to quit.")
        print("="*60)

